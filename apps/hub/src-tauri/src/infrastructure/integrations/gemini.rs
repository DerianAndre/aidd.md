use std::path::Path;
use crate::domain::model::{
    IntegrationConfig, IntegrationResult, IntegrationStatus, IntegrationType,
};
use super::adapter_trait::{ToolAdapter, ensure_file};

/// Gemini integration adapter.
///
/// Gemini reads AGENTS.md natively — minimal config needed.
///
/// Files managed:
/// - Project: `AGENTS.md` — agent definitions (shared across tools)
/// - Project: `.gemini/settings.json` — optional Gemini settings
pub struct GeminiAdapter;

impl ToolAdapter for GeminiAdapter {
    fn tool_type(&self) -> IntegrationType {
        IntegrationType::Gemini
    }

    fn integrate(&self, project_path: &Path, framework_path: &Path) -> Result<IntegrationResult, String> {
        let mut result = IntegrationResult {
            tool: IntegrationType::Gemini,
            files_created: Vec::new(),
            files_modified: Vec::new(),
            messages: Vec::new(),
        };

        // 1. Project AGENTS.md
        let agents_md = project_path.join("AGENTS.md");
        if !agents_md.exists() {
            let framework_agents = framework_path.join("AGENTS.md");
            let content = if framework_agents.exists() {
                std::fs::read_to_string(&framework_agents)
                    .map_err(|e| format!("Failed to read framework AGENTS.md: {}", e))?
            } else {
                generate_agents_md_stub()
            };
            if let Some(path) = ensure_file(&agents_md, &content)? {
                result.files_created.push(path);
            }
        } else {
            result.messages.push("AGENTS.md already exists — not overwritten".to_string());
        }

        // 2. Optional .gemini/settings.json
        let gemini_settings = project_path.join(".gemini").join("settings.json");
        let settings_content = serde_json::to_string_pretty(&serde_json::json!({
            "agentsFile": "AGENTS.md"
        }))
        .unwrap_or_default();

        if let Some(path) = ensure_file(&gemini_settings, &settings_content)? {
            result.files_created.push(path);
        } else {
            result.messages.push(".gemini/settings.json already exists — not overwritten".to_string());
        }

        result.messages.push("Gemini reads AGENTS.md natively — no additional config required".to_string());

        Ok(result)
    }

    fn remove(&self, project_path: &Path) -> Result<IntegrationResult, String> {
        let mut result = IntegrationResult {
            tool: IntegrationType::Gemini,
            files_created: Vec::new(),
            files_modified: Vec::new(),
            messages: Vec::new(),
        };

        // Remove .gemini/ directory
        let gemini_dir = project_path.join(".gemini");
        if gemini_dir.exists() {
            std::fs::remove_dir_all(&gemini_dir)
                .map_err(|e| format!("Failed to remove .gemini/: {}", e))?;
            result.messages.push(format!("Removed {}", gemini_dir.display()));
        }

        result.messages.push("AGENTS.md preserved (shared across integrations)".to_string());

        Ok(result)
    }

    fn check(&self, project_path: &Path) -> Result<IntegrationConfig, String> {
        let mut config_files = Vec::new();

        let agents_md = project_path.join("AGENTS.md");
        let has_agents_md = agents_md.exists();
        if has_agents_md {
            config_files.push(agents_md.to_string_lossy().to_string());
        }

        let gemini_settings = project_path.join(".gemini").join("settings.json");
        let has_settings = gemini_settings.exists();
        if has_settings {
            config_files.push(gemini_settings.to_string_lossy().to_string());
        }

        let status = if has_agents_md {
            IntegrationStatus::Configured
        } else {
            IntegrationStatus::NotConfigured
        };

        Ok(IntegrationConfig {
            integration_type: IntegrationType::Gemini,
            status,
            config_files,
        })
    }
}

fn generate_agents_md_stub() -> String {
    r#"# AGENTS.md — AI Agent Definitions

> Single Source of Truth for AI agent roles and coordination.
> Auto-generated by aidd.md Hub. Customize for your project.

## Orchestrator

The primary agent that coordinates all sub-agents and routes tasks.
"#
    .to_string()
}
