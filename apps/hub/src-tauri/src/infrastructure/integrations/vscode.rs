use std::path::Path;
use crate::domain::model::{
    IntegrationConfig, IntegrationResult, IntegrationStatus, IntegrationType,
};
use super::adapter_trait::{ToolAdapter, ensure_file, remove_file_if_exists};

/// VS Code / GitHub Copilot integration adapter.
///
/// Files managed:
/// - Project: `.github/copilot-instructions.md` — Copilot instructions
/// - Project: `AGENTS.md` — agent definitions (shared across tools)
///
/// Note: VS Code MCP settings require manual user config (settings.json).
/// The adapter provides guidance via messages.
pub struct VscodeAdapter;

impl ToolAdapter for VscodeAdapter {
    fn tool_type(&self) -> IntegrationType {
        IntegrationType::Vscode
    }

    fn integrate(&self, project_path: &Path, framework_path: &Path) -> Result<IntegrationResult, String> {
        let mut result = IntegrationResult {
            tool: IntegrationType::Vscode,
            files_created: Vec::new(),
            files_modified: Vec::new(),
            messages: Vec::new(),
        };

        // 1. Project: .github/copilot-instructions.md
        let copilot_md = project_path.join(".github").join("copilot-instructions.md");
        let content = generate_copilot_instructions(project_path);
        if let Some(path) = ensure_file(&copilot_md, &content)? {
            result.files_created.push(path);
        } else {
            result.messages.push("copilot-instructions.md already exists — not overwritten".to_string());
        }

        // 2. Project AGENTS.md
        let agents_md = project_path.join("AGENTS.md");
        if !agents_md.exists() {
            let framework_agents = framework_path.join("AGENTS.md");
            let content = if framework_agents.exists() {
                std::fs::read_to_string(&framework_agents)
                    .map_err(|e| format!("Failed to read framework AGENTS.md: {}", e))?
            } else {
                generate_agents_md_stub()
            };
            if let Some(path) = ensure_file(&agents_md, &content)? {
                result.files_created.push(path);
            }
        } else {
            result.messages.push("AGENTS.md already exists — not overwritten".to_string());
        }

        // 3. MCP setup guidance
        result.messages.push(
            "To enable aidd.md MCP in VS Code, add to your settings.json:\n\
             \"mcp\": { \"servers\": { \"aidd-engine\": { \"command\": \"npx\", \"args\": [\"-y\", \"@aidd.md/mcp-engine\"] } } }"
                .to_string(),
        );

        Ok(result)
    }

    fn remove(&self, project_path: &Path) -> Result<IntegrationResult, String> {
        let mut result = IntegrationResult {
            tool: IntegrationType::Vscode,
            files_created: Vec::new(),
            files_modified: Vec::new(),
            messages: Vec::new(),
        };

        let copilot_md = project_path.join(".github").join("copilot-instructions.md");
        if remove_file_if_exists(&copilot_md)? {
            result.messages.push(format!("Removed {}", copilot_md.display()));
        }

        result.messages.push("AGENTS.md preserved (shared across integrations)".to_string());
        result.messages.push(
            "Remember to remove the MCP entry from VS Code settings.json manually".to_string(),
        );

        Ok(result)
    }

    fn check(&self, project_path: &Path) -> Result<IntegrationConfig, String> {
        let mut config_files = Vec::new();

        let copilot_md = project_path.join(".github").join("copilot-instructions.md");
        let has_copilot = copilot_md.exists();
        if has_copilot {
            config_files.push(copilot_md.to_string_lossy().to_string());
        }

        let agents_md = project_path.join("AGENTS.md");
        let has_agents_md = agents_md.exists();
        if has_agents_md {
            config_files.push(agents_md.to_string_lossy().to_string());
        }

        let status = if has_copilot && has_agents_md {
            IntegrationStatus::Configured
        } else if has_copilot || has_agents_md {
            IntegrationStatus::NeedsUpdate
        } else {
            IntegrationStatus::NotConfigured
        };

        Ok(IntegrationConfig {
            integration_type: IntegrationType::Vscode,
            status,
            config_files,
        })
    }
}

fn generate_copilot_instructions(project_path: &Path) -> String {
    let project_name = project_path
        .file_name()
        .map(|n| n.to_string_lossy().to_string())
        .unwrap_or_else(|| "Project".to_string());

    format!(
r#"# {} — Copilot Instructions

> Auto-generated by aidd.md Hub. Edit freely.

## Agent Definitions

See `AGENTS.md` for the canonical source of truth on agent roles and coordination.

## Framework

This project uses the [aidd.md](https://aidd.md) AI-Driven Development framework.

### Key Files
- **AGENTS.md** — Agent definitions, routing, and coordination
- **rules/** — Domain-specific rules for code generation
- **skills/** — Specialized agent capabilities

## Guidelines

- Follow patterns in AGENTS.md for task routing
- Apply rules from `rules/` for domain-specific constraints
- Use TypeScript strict mode, ES modules only
- Evidence-first: logic/data/principles, never opinions
"#,
        project_name
    )
}

fn generate_agents_md_stub() -> String {
    r#"# AGENTS.md — AI Agent Definitions

> Single Source of Truth for AI agent roles and coordination.
> Auto-generated by aidd.md Hub. Customize for your project.

## Orchestrator

The primary agent that coordinates all sub-agents and routes tasks.
"#
    .to_string()
}
