use std::path::{Path, PathBuf};
use crate::domain::model::{IntegrationConfig, IntegrationResult, IntegrationType};

/// Infrastructure trait — each AI tool adapter implements this.
pub(crate) trait ToolAdapter: Send + Sync {
    fn tool_type(&self) -> IntegrationType;
    fn integrate(&self, project_path: &Path, framework_path: &Path, dev_mode: bool) -> Result<IntegrationResult, String>;
    fn remove(&self, project_path: &Path) -> Result<IntegrationResult, String>;
    fn check(&self, project_path: &Path) -> Result<IntegrationConfig, String>;
}

/// Generate the MCP server JSON entry.
/// In dev mode, points to the local dist/index.js; otherwise uses npx.
pub(crate) fn mcp_server_entry(project_path: &Path, dev_mode: bool) -> serde_json::Value {
    if dev_mode {
        let engine_path = project_path.join("mcps").join("mcp-aidd-engine").join("dist").join("index.js");
        serde_json::json!({
            "command": "node",
            "args": [engine_path.to_string_lossy()]
        })
    } else {
        serde_json::json!({
            "command": "npx",
            "args": ["-y", "@aidd.md/mcp-engine"]
        })
    }
}

/// Check if an existing MCP server entry is in dev mode (command is "node").
pub(crate) fn is_dev_mode_entry(entry: &serde_json::Value) -> bool {
    entry.get("command").and_then(|c| c.as_str()) == Some("node")
}

/// Helper: ensure a file exists, creating parent dirs and writing content if missing.
/// Returns `Some(path_str)` if the file was created, `None` if it already existed.
pub(crate) fn ensure_file(path: &Path, content: &str) -> Result<Option<String>, String> {
    if path.exists() {
        return Ok(None);
    }
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("Failed to create dir {}: {}", parent.display(), e))?;
    }
    std::fs::write(path, content)
        .map_err(|e| format!("Failed to write {}: {}", path.display(), e))?;
    Ok(Some(path.to_string_lossy().to_string()))
}

/// Helper: read a JSON file, returning a default Value if it doesn't exist.
pub(crate) fn read_json_or_default(path: &Path) -> Result<serde_json::Value, String> {
    if !path.exists() {
        return Ok(serde_json::json!({}));
    }
    let content = std::fs::read_to_string(path)
        .map_err(|e| format!("Failed to read {}: {}", path.display(), e))?;
    serde_json::from_str(&content)
        .map_err(|e| format!("Failed to parse {}: {}", path.display(), e))
}

/// Helper: write a JSON value to a file (pretty-printed), creating parent dirs.
pub(crate) fn write_json(path: &Path, value: &serde_json::Value) -> Result<(), String> {
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("Failed to create dir {}: {}", parent.display(), e))?;
    }
    let content = serde_json::to_string_pretty(value)
        .map_err(|e| format!("Failed to serialize JSON: {}", e))?;
    std::fs::write(path, content)
        .map_err(|e| format!("Failed to write {}: {}", path.display(), e))
}

/// Helper: remove a file if it exists. Returns true if removed.
pub(crate) fn remove_file_if_exists(path: &Path) -> Result<bool, String> {
    if path.exists() {
        std::fs::remove_file(path)
            .map_err(|e| format!("Failed to remove {}: {}", path.display(), e))?;
        Ok(true)
    } else {
        Ok(false)
    }
}

// ---------------------------------------------------------------------------
// Shared agent templates (SSOT — used by all adapters)
// ---------------------------------------------------------------------------

/// Default agents routing.md content for new projects.
pub(crate) fn agents_content() -> String {
    r#"# AIDD — AI Agent Definitions

> Single Source of Truth for AI agent roles and coordination.
> Auto-generated by aidd.md Hub. Customize for your project.

## Orchestrator

The primary agent that coordinates all sub-agents and routes tasks.

### Capabilities
- Task classification and routing
- Context optimization
- Quality gate enforcement

## Rules

See `.aidd/content/rules/` for domain-specific rules.

## Skills

See `.aidd/content/skills/` for specialized capabilities.
"#
    .to_string()
}

/// Thin AGENTS.md redirect for cross-tool compatibility.
pub(crate) fn agents_redirect() -> String {
    r#"# AGENTS.md

> Cross-tool AI instructions for aidd.md projects.

## Startup Protocol

**At the start of every conversation, do one of the following:**

1. **MCP available** — Call the `aidd_start` MCP tool.
2. **MCP unavailable** — Run `pnpm mcp:check` in the terminal.

## Agent Definitions

See [.aidd/content/routing.md](.aidd/content/routing.md) for the full agent hierarchy.
"#
    .to_string()
}

/// Ensure the project has agents content (routing.md) and AGENTS.md redirect.
/// Uses config-aware path resolution and framework fallback.
pub(crate) fn ensure_agents_files(
    project_path: &Path,
    framework_path: &Path,
    result: &mut IntegrationResult,
) -> Result<(), String> {
    // 1. Agents routing.md at content root
    let routing_file = resolve_content_dir(project_path, "").join("routing.md");
    if !routing_file.exists() {
        let framework_routing = framework_path.join("routing.md");
        let content = if framework_routing.exists() {
            std::fs::read_to_string(&framework_routing)
                .map_err(|e| format!("Failed to read framework routing.md: {}", e))?
        } else {
            // Fallback: check legacy location
            let legacy_routing = framework_path.join("agents").join("routing.md");
            if legacy_routing.exists() {
                std::fs::read_to_string(&legacy_routing)
                    .map_err(|e| format!("Failed to read framework routing.md: {}", e))?
            } else {
                agents_content()
            }
        };
        if let Some(path) = ensure_file(&routing_file, &content)? {
            result.files_created.push(path);
        }
    } else {
        result.messages.push("routing.md already exists — not overwritten".to_string());
    }

    // 2. Thin AGENTS.md redirect at root
    let redirect = project_path.join("AGENTS.md");
    if !redirect.exists() {
        if let Some(path) = ensure_file(&redirect, &agents_redirect())? {
            result.files_created.push(path);
        }
    }

    Ok(())
}

/// Check if routing.md exists (config-aware), with backward compat for legacy agents/ dir.
pub(crate) fn has_agents_dir(project_path: &Path) -> bool {
    let routing_file = resolve_content_dir(project_path, "").join("routing.md");
    if routing_file.exists() {
        return true;
    }
    // Backward compat: check legacy agents/ directory
    resolve_content_dir(project_path, "agents").exists()
}

/// Get the routing.md path (config-aware) for status reporting.
pub(crate) fn agents_dir_path(project_path: &Path) -> PathBuf {
    resolve_content_dir(project_path, "").join("routing.md")
}

// ---------------------------------------------------------------------------
// SSOT: Project instructions & rules pointers
// ---------------------------------------------------------------------------

/// Project instructions template — each tool supplies its name and MCP note.
pub(crate) fn project_instructions(project_name: &str, tool_name: &str, mcp_note: &str) -> String {
    format!(
r#"# {} — {} Instructions

> Auto-generated by aidd.md. Edit freely.

## Startup Protocol

**At the start of every conversation, do one of the following:**

1. **MCP available** — Call the `aidd_start` MCP tool.
2. **MCP unavailable** — Run `pnpm mcp:check` in the terminal.

## SSOT

`.aidd/content/routing.md` is the canonical source of truth for agent roles and coordination.

## Framework

This project uses the [aidd.md](https://aidd.md) framework for AI-Driven Development:
- **.aidd/content/routing.md** — Agent definitions and routing
- **.aidd/content/rules/** — Domain-specific rules
- **.aidd/content/skills/** — Specialized capabilities
- **.aidd/content/workflows/** — Multi-step procedures

## MCP Integration

{}
"#,
        project_name, tool_name, mcp_note
    )
}

/// Thin rules pointer (used by Cursor .mdc and Windsurf .windsurfrules).
pub(crate) fn rules_pointer() -> String {
    r#"This project uses the aidd.md framework for AI-Driven Development.

## Startup Protocol

At the start of every conversation, call the `aidd_start` MCP tool.
If MCP is unavailable, run `pnpm mcp:check` in the terminal.

## Framework

- Agent definitions: `.aidd/content/routing.md`
- Domain rules: `.aidd/content/rules/`
- Skills: `.aidd/content/skills/`
- Workflows: `.aidd/content/workflows/`

Follow the patterns and conventions defined in these directories.
"#
    .to_string()
}

/// Extract a project name from the project path.
pub(crate) fn project_name(project_path: &Path) -> String {
    project_path
        .file_name()
        .map(|n| n.to_string_lossy().to_string())
        .unwrap_or_else(|| "Project".to_string())
}

// ---------------------------------------------------------------------------
// MCP JSON helpers for integrations with MCP configs
// ---------------------------------------------------------------------------

/// Upsert the aidd-engine entry in an MCP JSON config file.
/// Returns (was_created, was_modified).
pub(crate) fn upsert_mcp_entry(
    mcp_path: &Path,
    project_path: &Path,
    dev_mode: bool,
    result: &mut IntegrationResult,
) -> Result<(), String> {
    let mut config = read_json_or_default(mcp_path)?;

    let servers = config
        .as_object_mut()
        .ok_or("MCP config is not a JSON object")?
        .entry("mcpServers")
        .or_insert_with(|| serde_json::json!({}));

    let had_entry = servers.get("aidd-engine").is_some();
    servers
        .as_object_mut()
        .ok_or("mcpServers is not a JSON object")?
        .insert("aidd-engine".to_string(), mcp_server_entry(project_path, dev_mode));

    write_json(mcp_path, &config)?;
    if had_entry {
        result.files_modified.push(mcp_path.to_string_lossy().to_string());
    } else {
        result.files_created.push(mcp_path.to_string_lossy().to_string());
    }
    Ok(())
}

/// Remove the aidd-engine entry from an MCP JSON config file.
pub(crate) fn remove_mcp_entry(
    mcp_path: &Path,
    result: &mut IntegrationResult,
) -> Result<(), String> {
    if !mcp_path.exists() {
        return Ok(());
    }
    let mut config = read_json_or_default(mcp_path)?;
    if let Some(servers) = config.get_mut("mcpServers").and_then(|s| s.as_object_mut()) {
        if servers.remove("aidd-engine").is_some() {
            write_json(mcp_path, &config)?;
            result.files_modified.push(mcp_path.to_string_lossy().to_string());
        }
    }
    Ok(())
}

/// Check if an MCP JSON file has an aidd-engine entry.
/// Returns (has_entry, is_dev_mode).
pub(crate) fn check_mcp_entry(mcp_path: &Path) -> Result<(bool, bool), String> {
    if !mcp_path.exists() {
        return Ok((false, false));
    }
    let config = read_json_or_default(mcp_path)?;
    match config.get("mcpServers").and_then(|s| s.get("aidd-engine")) {
        Some(entry) => Ok((true, is_dev_mode_entry(entry))),
        None => Ok((false, false)),
    }
}

// ---------------------------------------------------------------------------
// Content path resolution
// ---------------------------------------------------------------------------

/// Resolve the content path for a category, respecting .aidd/config.json overrides.
/// Priority: config path override → .aidd/content/<category>/ (default)
pub(crate) fn resolve_content_dir(project_path: &Path, category: &str) -> PathBuf {
    let aidd_dir = project_path.join(".aidd");
    let config_path = aidd_dir.join("config.json");

    if let Ok(raw) = std::fs::read_to_string(&config_path) {
        if let Ok(json) = serde_json::from_str::<serde_json::Value>(&raw) {
            if let Some(paths) = json.get("content").and_then(|c| c.get("paths")) {
                // Check per-category override
                if let Some(override_path) = paths.get(category).and_then(|v| v.as_str()) {
                    return aidd_dir.join(override_path);
                }
                // Check base content dir override
                if let Some(base) = paths.get("content").and_then(|v| v.as_str()) {
                    return aidd_dir.join(base).join(category);
                }
            }
        }
    }

    // Default: .aidd/content/<category>/
    aidd_dir.join("content").join(category)
}
