# ADR: Hub Memory Service — DDD + Hexagonal Architecture

> Architecture Decision Record
> **Date**: 2026-02-07
> **Status**: Implemented
> **Deciders**: Project Lead + AI Architect

---

## Context

The Hub app (Tauri 2 + React 19) had no memory visualization. The AIDD MCP engine stores session, observation, evolution, and pattern data in `.aidd/data.db` (SQLite), but the Hub couldn't access or display this data.

The Hub's existing architecture uses DDD + Hexagonal patterns in Rust (domain/ports → application → infrastructure → presentation). The memory feature needed to follow the same patterns.

Two access strategies were considered:
1. Query the SQLite database directly from the Tauri backend
2. Call the MCP engine via JSON-RPC protocol

---

## Decision

### 1. Hexagonal Architecture with Port Abstraction

Define a `MemoryPort` trait in the domain layer. Both access strategies implement this trait. The application layer (MemoryService) depends only on the abstraction.

```
MemoryPort (trait)
    ├── SqliteMemoryAdapter (direct DB access — implemented)
    └── McpMemoryAdapter (JSON-RPC client — stub)
```

**Why port abstraction?**
- Allows swapping adapters without touching domain or application code
- SQLite adapter provides immediate functionality
- MCP adapter can be implemented later when JSON-RPC client is ready
- Follows existing Hub patterns (FrameworkPort, ProjectPort, McpPort)

### 2. SQLite as Primary Adapter

Use `SqliteMemoryAdapter` as the working implementation. It opens the active project's `.aidd/data.db` read-only and queries session/observation/evolution/pattern tables directly.

**Why SQLite over MCP?**
- Zero latency (no IPC, no process communication)
- Works even when MCP engine is not running
- Read-only queries — no mutation risk
- The database schema is stable (16 tables, documented in MCP memory package)

**Why not MCP?**
- JSON-RPC client for Tauri doesn't exist yet
- Would require spawning/connecting to engine process
- Adds latency and failure modes for read-only data
- Will be implemented as McpMemoryAdapter when client infrastructure is ready

### 3. Dynamic Project Path Resolution

The adapter receives `Arc<ProjectService>` and resolves the database path on every query by calling `get_active_path()`. This handles project switching without restarting the app.

**Why dynamic, not static?**
- Users can switch active projects at runtime
- Storing a fixed path would require re-initialization on project change
- The cost of one `get_active_path()` call per query is negligible

### 4. Graceful Degradation

All queries return empty data structures on failure (no active project, missing database, missing tables). The frontend displays zeros instead of errors.

**Why silent failures?**
- Memory data is informational, not critical
- First-time users won't have a database yet
- Errors in memory queries should not block the rest of the Hub

---

## Alternatives Considered

| Alternative | Rejected Because |
|------------|-----------------|
| MCP-only adapter | JSON-RPC client doesn't exist. Would ship with zero functionality. |
| Shared SQLite connection | Rust and Node.js can't share a connection across processes safely. |
| REST API from engine | Over-engineering. The data is local, no network needed. |
| Embed memory in Hub state | Would duplicate MCP engine's storage logic. Violates single source of truth. |

---

## Consequences

**Positive:**
- Memory data visible in Hub immediately (with active project)
- Architecture is clean and follows existing patterns
- Adapter is swappable when MCP client is ready
- No additional dependencies (rusqlite already in Cargo.toml)

**Negative:**
- Two processes can read the same SQLite file (Hub + MCP engine). WAL mode handles this, but awareness is needed.
- Schema changes in MCP engine require updating adapter queries manually.
- McpMemoryAdapter is a dead-code stub until JSON-RPC client is implemented.

---

## Cross-References

- **Plan**: `docs/plans/active/2026.02.07-hub-memory-ddd-plan.md`
- **Diagram**: `docs/plans/active/2026.02.07-hub-memory-ddd-diagram.md`
- **SQLite schema**: `mcps/mcp-aidd-memory/src/storage/migrations.ts`
- **Existing Hexagonal reference**: `apps/hub/src-tauri/src/domain/ports/inbound/framework_port.rs`
