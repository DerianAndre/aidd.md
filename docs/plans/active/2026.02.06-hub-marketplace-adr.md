# ADR: Hub Marketplace

> Architecture Decision Record
> **Date**: 2026-02-06
> **Status**: Accepted
> **Deciders**: Project Lead

---

## Context

The AIDD Hub app (Tauri 2 + React 19 + shadcn/ui) needs a way for users to discover, browse, and install MCP servers and AIDD content (skills, workflows, rules, templates, knowledge). Currently, users must manually find and configure these resources. A marketplace provides a centralized discovery and installation experience.

Inspirations: cursor.directory/mcp (MCP server cards), cursor.directory/rules (tag-based taxonomy), skills.sh (leaderboard, search, trending).

## Decision

### 1. Remote-First Registry with Static Fallback

**Fetch catalog data from a GitHub-hosted JSON registry at runtime**, with baked-in static data as fallback.

- Primary: `raw.githubusercontent.com/aidd-md/registry/main/*.json`
- Fallback: static seed data compiled into the app
- Cache: in-memory (Zustand store), optionally persisted via Tauri to `.aidd/cache/marketplace/`

**Why GitHub-hosted JSON, not a real API?**
- Zero infrastructure cost — GitHub raw URLs are free and fast
- JSON files are diffable, PR-reviewable, community-contributable
- Swappable to a real API later without changing the client (same JSON schema)
- The registry repo (`aidd-md/registry`) can be created independently

**Why static fallback?**
- App works offline and before the registry repo exists
- Seed data doubles as development fixtures
- Graceful degradation with stale badge UI

### 2. Dual View Modes (Grid + List)

**Support both card grid and table list views**, toggleable by the user.

- Grid: visual browsing with cards (name, description, author, category, install count)
- List: power-user table with sortable columns

**Why both?**
- Grid is more engaging for discovery (cursor.directory pattern)
- List is more efficient for scanning large catalogs (skills.sh pattern)
- Toggle is a single state variable, minimal implementation cost

### 3. Client-Side Filtering with URL Persistence

**Fetch the full catalog once, filter/sort/search entirely on the client.**

- Filters: text search, category chips, sort (popular/trending/newest/alphabetical)
- Filter state persisted to URL search params (shareable, bookmarkable)
- No server-side pagination or filtering needed

**Why client-side?**
- Catalog size is small (< 500 entries for years to come)
- Instant filtering — no network round-trips per keystroke
- URL persistence makes states shareable without backend sessions

### 4. Discriminated Union Types

**Use `McpServerEntry | ContentEntry` with a `type` discriminant**, not a mega-interface.

- `McpServerEntry`: has `installConfig`, `transport`, `features`, `configTargets`
- `ContentEntry`: has `contentType` (skill/workflow/rule/template/knowledge), `agentCompatibility`
- Type narrowing via `entry.type === 'mcp-server'` or `entry.type === 'content'`

**Why not a single interface?**
- MCP servers and AIDD content have fundamentally different metadata
- Discriminated unions enable TypeScript narrowing — no optional fields everywhere
- Conditional rendering in card/detail components is cleaner

### 5. Two-Tier Install Flow

**Primary: copy config to clipboard. Secondary: Tauri file-write to config targets.**

- Copy-to-clipboard: safe, universal, works for any MCP client
- "Install directly": Tauri dialog for selecting config file target + file write
- Config targets defined per entry (e.g., `~/.claude/config.json`, `.cursor/mcp.json`)

**Why copy-to-clipboard as primary?**
- Zero risk — user pastes manually, maintains control
- Works even if config file locations change
- "Install directly" is opt-in power-user feature

### 6. Feature-Sliced File Organization

**All marketplace code under `apps/hub/src/features/marketplace/`** with lib/stores/components/pages structure.

```
marketplace/
  lib/        (types, constants, registry, helpers — pure logic)
  stores/     (Zustand store — state management)
  components/ (UI components — card, table, filter, install)
  pages/      (page compositions — list, detail)
```

**Why feature-sliced?**
- Self-contained — all marketplace code in one directory
- Clear separation: lib (pure) → stores (state) → components (UI) → pages (composition)
- Easy to delete or refactor independently

### 7. Tab-Based Content Separation

**Two tabs: "MCP Servers" and "Skills & Content"**, not a single mixed view.

- Each tab shows only relevant entries with contextual filter chips
- Entry counts shown in tab labels
- Active tab determines available category filters

**Why tabs, not a single list?**
- MCP servers and AIDD content have different metadata shapes
- Users typically look for one or the other, not both
- Contextual filters reduce cognitive load

## Consequences

### Positive
- Works offline with static fallback data
- Zero backend infrastructure required
- URL-persistent filters enable sharing
- Type-safe entry handling via discriminated unions
- Both visual and power-user browsing modes
- Safe install flow with clipboard-first approach
- Feature-isolated code organization

### Negative
- Full catalog loaded in memory (acceptable for < 500 entries)
- GitHub raw URLs have rate limits (60 req/hr unauthenticated)
- Static fallback data goes stale without app updates
- Two install flows increase surface area to test

### Risks
- Registry repo format changes break the client — mitigated by schema versioning in JSON
- GitHub raw URL downtime — mitigated by static fallback + stale badge
- Catalog grows beyond client-side filtering capacity — mitigated by future API migration path

## Alternatives Considered

| Alternative | Why Rejected |
|------------|-------------|
| Real API backend | Premature — adds infra cost, auth complexity, deployment burden |
| Embedded database (SQLite) | Overkill for < 500 entries, adds complexity |
| Server-side filtering | Unnecessary latency, requires backend |
| Single mixed view | Confusing UX — MCP servers and content have different needs |
| Auto-install only | Too risky — users should control config file modifications |
| Separate pages per type | Too much navigation — tabs keep everything accessible |
