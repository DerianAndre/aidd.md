/**
 * Integration adapters — write config files for AI tools.
 * Node.js port of the Rust integration adapters from Hub.
 */
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { homedir } from 'node:os';
import { join, resolve } from 'node:path';

export type IntegrationTool = 'claude' | 'cursor' | 'vscode' | 'gemini';

export interface IntegrationResult {
  tool: IntegrationTool;
  files_created: string[];
  files_modified: string[];
  messages: string[];
}

const TOOLS: IntegrationTool[] = ['claude', 'cursor', 'vscode', 'gemini'];

export function listTools(): IntegrationTool[] {
  return [...TOOLS];
}

export function integrate(projectPath: string, tool: IntegrationTool): IntegrationResult {
  const absPath = resolve(projectPath);
  switch (tool) {
    case 'claude':
      return integrateClaude(absPath);
    case 'cursor':
      return integrateCursor(absPath);
    case 'vscode':
      return integrateVscode(absPath);
    case 'gemini':
      return integrateGemini(absPath);
  }
}

export function integrateAll(projectPath: string): IntegrationResult[] {
  return TOOLS.map((tool) => integrate(projectPath, tool));
}

// ── Claude Code ────────────────────────────────────────────────────────────

function integrateClaude(projectPath: string): IntegrationResult {
  const result: IntegrationResult = { tool: 'claude', files_created: [], files_modified: [], messages: [] };

  // Global: update ~/.claude/mcp.json
  const claudeDir = join(homedir(), '.claude');
  const mcpJsonPath = join(claudeDir, 'mcp.json');
  if (!existsSync(claudeDir)) mkdirSync(claudeDir, { recursive: true });

  let mcpConfig: Record<string, unknown> = {};
  if (existsSync(mcpJsonPath)) {
    try {
      mcpConfig = JSON.parse(readFileSync(mcpJsonPath, 'utf-8'));
      result.files_modified.push(mcpJsonPath);
    } catch {
      result.files_modified.push(mcpJsonPath);
    }
  } else {
    result.files_created.push(mcpJsonPath);
  }

  const servers = (mcpConfig['mcpServers'] ?? {}) as Record<string, unknown>;
  servers['aidd-engine'] = {
    command: 'npx',
    args: ['-y', '@aidd.md/mcp-engine'],
    env: { AIDD_PROJECT_PATH: projectPath },
  };
  mcpConfig['mcpServers'] = servers;
  writeFileSync(mcpJsonPath, JSON.stringify(mcpConfig, null, 2), 'utf-8');

  // Project: generate CLAUDE.md
  const claudeMdPath = join(projectPath, 'CLAUDE.md');
  if (!existsSync(claudeMdPath)) {
    const content = [
      '# Project Instructions for Claude Code',
      '',
      '> Generated by aidd.md CLI',
      '',
      'See [AGENTS.md](AGENTS.md) for agent roles and coordination.',
      'See [rules/](rules/) for domain-specific rules.',
      '',
    ].join('\n');
    writeFileSync(claudeMdPath, content, 'utf-8');
    result.files_created.push(claudeMdPath);
  }

  result.messages.push('Claude Code: MCP server configured globally');
  return result;
}

// ── Cursor ─────────────────────────────────────────────────────────────────

function integrateCursor(projectPath: string): IntegrationResult {
  const result: IntegrationResult = { tool: 'cursor', files_created: [], files_modified: [], messages: [] };

  // Project: .cursor/mcp.json
  const cursorDir = join(projectPath, '.cursor');
  if (!existsSync(cursorDir)) mkdirSync(cursorDir, { recursive: true });

  const mcpJsonPath = join(cursorDir, 'mcp.json');
  let mcpConfig: Record<string, unknown> = {};
  if (existsSync(mcpJsonPath)) {
    try {
      mcpConfig = JSON.parse(readFileSync(mcpJsonPath, 'utf-8'));
      result.files_modified.push(mcpJsonPath);
    } catch {
      result.files_modified.push(mcpJsonPath);
    }
  } else {
    result.files_created.push(mcpJsonPath);
  }

  const servers = (mcpConfig['mcpServers'] ?? {}) as Record<string, unknown>;
  servers['aidd-engine'] = {
    command: 'npx',
    args: ['-y', '@aidd.md/mcp-engine'],
    env: { AIDD_PROJECT_PATH: projectPath },
  };
  mcpConfig['mcpServers'] = servers;
  writeFileSync(mcpJsonPath, JSON.stringify(mcpConfig, null, 2), 'utf-8');

  result.messages.push('Cursor: MCP server configured for project');
  return result;
}

// ── VS Code / Copilot ──────────────────────────────────────────────────────

function integrateVscode(projectPath: string): IntegrationResult {
  const result: IntegrationResult = { tool: 'vscode', files_created: [], files_modified: [], messages: [] };

  // Project: .github/copilot-instructions.md
  const githubDir = join(projectPath, '.github');
  if (!existsSync(githubDir)) mkdirSync(githubDir, { recursive: true });

  const instrPath = join(githubDir, 'copilot-instructions.md');
  if (!existsSync(instrPath)) {
    const content = [
      '# Copilot Instructions',
      '',
      '> Generated by aidd.md CLI',
      '',
      'This project uses the aidd.md framework for AI-Driven Development.',
      '',
      'See [AGENTS.md](../AGENTS.md) for agent roles and coordination.',
      'See [rules/](../rules/) for domain-specific rules.',
      '',
    ].join('\n');
    writeFileSync(instrPath, content, 'utf-8');
    result.files_created.push(instrPath);
  }

  result.messages.push('VS Code: copilot-instructions.md created');
  return result;
}

// ── Gemini ─────────────────────────────────────────────────────────────────

function integrateGemini(projectPath: string): IntegrationResult {
  const result: IntegrationResult = { tool: 'gemini', files_created: [], files_modified: [], messages: [] };

  // Gemini auto-reads AGENTS.md — just verify it exists
  const agentsMdPath = join(projectPath, 'AGENTS.md');
  if (existsSync(agentsMdPath)) {
    result.messages.push('Gemini: AGENTS.md found — Gemini will auto-detect it');
  } else {
    result.messages.push('Gemini: AGENTS.md not found — create one for Gemini support');
  }

  return result;
}
