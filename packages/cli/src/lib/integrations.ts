/**
 * Integration adapters — write config files for AI tools.
 * Node.js port of the Rust integration adapters from Hub.
 */
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { homedir } from 'node:os';
import { dirname, join, resolve } from 'node:path';

export type IntegrationTool = 'claude' | 'cursor' | 'vscode' | 'gemini' | 'windsurf';

export interface IntegrationResult {
  tool: IntegrationTool;
  files_created: string[];
  files_modified: string[];
  messages: string[];
}

const TOOLS: IntegrationTool[] = ['claude', 'cursor', 'vscode', 'gemini', 'windsurf'];

// ── SSOT Content Templates ─────────────────────────────────────────────────

const AGENTS_REDIRECT = `# AGENTS.md

> Thin redirect for cross-tool compatibility (Gemini, Copilot, etc.)
> Canonical agent definitions live in \`.aidd/content/agents/\`.

See [.aidd/content/agents/routing.md](.aidd/content/agents/routing.md) for the full agent hierarchy.
`;

const RULES_POINTER = `This project uses the aidd.md framework for AI-Driven Development.

- Agent definitions: \`.aidd/content/agents/\`
- Domain rules: \`.aidd/content/rules/\`
- Skills: \`.aidd/content/skills/\`
- Workflows: \`.aidd/content/workflows/\`

Follow the patterns and conventions defined in these directories.
`;

function projectInstructions(projectName: string, toolName: string, mcpNote: string): string {
  return `# ${projectName} — ${toolName} Instructions

> Auto-generated by aidd.md. Edit freely.

## SSOT

\`.aidd/content/agents/\` is the canonical source of truth for agent roles and coordination.

## Framework

This project uses the [aidd.md](https://aidd.md) framework for AI-Driven Development:
- **.aidd/content/agents/** — Agent definitions and routing
- **.aidd/content/rules/** — Domain-specific rules
- **.aidd/content/skills/** — Specialized capabilities
- **.aidd/content/workflows/** — Multi-step procedures

## MCP Integration

${mcpNote}
`;
}

// ── Shared Helpers ──────────────────────────────────────────────────────────

function projectName(projectPath: string): string {
  return projectPath.split(/[\\/]/).pop() ?? 'Project';
}

function upsertMcpConfig(
  configPath: string,
  projectPath: string,
  serversKey: string,
  entry: Record<string, unknown>,
  result: IntegrationResult,
): void {
  const dir = join(configPath, '..');
  if (!existsSync(dir)) mkdirSync(dir, { recursive: true });

  let config: Record<string, unknown> = {};
  if (existsSync(configPath)) {
    try {
      config = JSON.parse(readFileSync(configPath, 'utf-8'));
      result.files_modified.push(configPath);
    } catch {
      result.files_modified.push(configPath);
    }
  } else {
    result.files_created.push(configPath);
  }

  const servers = (config[serversKey] ?? {}) as Record<string, unknown>;
  servers['aidd-engine'] = entry;
  config[serversKey] = servers;
  writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf-8');
}

function ensureFile(filePath: string, content: string, result: IntegrationResult): void {
  if (existsSync(filePath)) return;
  const dir = join(filePath, '..');
  if (!existsSync(dir)) mkdirSync(dir, { recursive: true });
  writeFileSync(filePath, content, 'utf-8');
  result.files_created.push(filePath);
}

function ensureAgentsRedirect(projectPath: string, result: IntegrationResult): void {
  ensureFile(join(projectPath, 'AGENTS.md'), AGENTS_REDIRECT, result);
}

function mcpEntry(projectPath: string, devMode: boolean) {
  if (devMode) {
    // Dev/contributor: point to local build (fast cold-start, works offline)
    return {
      command: 'node',
      args: [join(projectPath, 'mcps', 'mcp-aidd-engine', 'dist', 'index.js')],
      env: { AIDD_PROJECT_PATH: projectPath },
    };
  }
  // Adopter: use npx (portable, always resolves from registry)
  return {
    command: 'npx',
    args: ['-y', '@aidd.md/mcp-engine'],
    env: { AIDD_PROJECT_PATH: projectPath },
  };
}

/** Detect dev mode: true if the local engine build exists */
export function detectDevMode(projectPath: string): boolean {
  return existsSync(join(resolve(projectPath), 'mcps', 'mcp-aidd-engine', 'dist', 'index.js'));
}

// ── Public API ──────────────────────────────────────────────────────────────

export function listTools(): IntegrationTool[] {
  return [...TOOLS];
}

export function integrate(projectPath: string, tool: IntegrationTool, devMode?: boolean): IntegrationResult {
  const absPath = resolve(projectPath);
  const dev = devMode ?? detectDevMode(absPath);
  switch (tool) {
    case 'claude':
      return integrateClaude(absPath, dev);
    case 'cursor':
      return integrateCursor(absPath, dev);
    case 'vscode':
      return integrateVscode(absPath, dev);
    case 'gemini':
      return integrateGemini(absPath);
    case 'windsurf':
      return integrateWindsurf(absPath, dev);
  }
}

export function integrateAll(projectPath: string, devMode?: boolean): IntegrationResult[] {
  return TOOLS.map((tool) => integrate(projectPath, tool, devMode));
}

// ── Claude Code ────────────────────────────────────────────────────────────

function integrateClaude(projectPath: string, devMode: boolean): IntegrationResult {
  const result: IntegrationResult = { tool: 'claude', files_created: [], files_modified: [], messages: [] };
  const entry = mcpEntry(projectPath, devMode);

  // 1. User scope: ~/.claude.json
  const mcpJsonPath = join(homedir(), '.claude.json');
  upsertMcpConfig(mcpJsonPath, projectPath, 'mcpServers', entry, result);

  // 2. Project-scoped: .mcp.json (team-shareable via git)
  const projectMcp = join(projectPath, '.mcp.json');
  if (!existsSync(projectMcp)) {
    upsertMcpConfig(projectMcp, projectPath, 'mcpServers', entry, result);
  }

  // 3. Project: CLAUDE.md
  const name = projectName(projectPath);
  ensureFile(
    join(projectPath, 'CLAUDE.md'),
    projectInstructions(name, 'Claude Code', 'The aidd.md MCP server is configured at `~/.claude.json` (user scope) and `.mcp.json` (project scope).'),
    result,
  );

  // 4. AGENTS.md redirect
  ensureAgentsRedirect(projectPath, result);

  const mode = devMode ? 'dev' : 'npx';
  result.messages.push(`Claude Code: MCP server configured (${mode}, user + project scope)`);
  return result;
}

// ── Cursor ─────────────────────────────────────────────────────────────────

function integrateCursor(projectPath: string, devMode: boolean): IntegrationResult {
  const result: IntegrationResult = { tool: 'cursor', files_created: [], files_modified: [], messages: [] };

  // 1. Project: .cursor/mcp.json
  const mcpJsonPath = join(projectPath, '.cursor', 'mcp.json');
  upsertMcpConfig(mcpJsonPath, projectPath, 'mcpServers', mcpEntry(projectPath, devMode), result);

  // 2. Project: .cursor/rules/aidd.mdc (thin pointer with frontmatter)
  const mdcContent = `---
description: "AIDD framework rules — AI-Driven Development"
alwaysApply: true
globs: []
---

# AIDD Framework

${RULES_POINTER}`;
  ensureFile(join(projectPath, '.cursor', 'rules', 'aidd.mdc'), mdcContent, result);

  // 3. AGENTS.md redirect
  ensureAgentsRedirect(projectPath, result);

  result.messages.push('Cursor: MCP server + rules configured for project');
  return result;
}

// ── VS Code / Copilot ──────────────────────────────────────────────────────

function integrateVscode(projectPath: string, devMode: boolean): IntegrationResult {
  const result: IntegrationResult = { tool: 'vscode', files_created: [], files_modified: [], messages: [] };

  // 1. Project: .vscode/mcp.json (VS Code native MCP format)
  const vscodeMcpPath = join(projectPath, '.vscode', 'mcp.json');
  const vscodeEntry = { type: 'stdio', ...mcpEntry(projectPath, devMode) };
  upsertMcpConfig(vscodeMcpPath, projectPath, 'servers', vscodeEntry, result);

  // 2. Project: .github/copilot-instructions.md
  const name = projectName(projectPath);
  ensureFile(
    join(projectPath, '.github', 'copilot-instructions.md'),
    projectInstructions(name, 'Copilot', 'The aidd.md MCP server is configured at `.vscode/mcp.json`.'),
    result,
  );

  // 3. AGENTS.md redirect
  ensureAgentsRedirect(projectPath, result);

  result.messages.push('VS Code: MCP server + copilot-instructions.md configured');
  return result;
}

// ── Gemini ─────────────────────────────────────────────────────────────────

function integrateGemini(projectPath: string): IntegrationResult {
  const result: IntegrationResult = { tool: 'gemini', files_created: [], files_modified: [], messages: [] };

  // 1. AGENTS.md redirect (Gemini reads this natively)
  ensureAgentsRedirect(projectPath, result);

  // 2. Optional .gemini/settings.json
  ensureFile(
    join(projectPath, '.gemini', 'settings.json'),
    JSON.stringify({ agentsFile: 'AGENTS.md' }, null, 2),
    result,
  );

  const agentsDir = join(projectPath, '.aidd', 'content', 'agents');
  if (existsSync(agentsDir)) {
    result.messages.push('Gemini: AGENTS.md redirect + .gemini/settings.json configured');
  } else {
    result.messages.push('Gemini: configured — run scaffold to create .aidd/content/agents/');
  }

  return result;
}

// ── Windsurf / Antigravity ─────────────────────────────────────────────────

function integrateWindsurf(projectPath: string, devMode: boolean): IntegrationResult {
  const result: IntegrationResult = { tool: 'windsurf', files_created: [], files_modified: [], messages: [] };

  // 1. Global: ~/.codeium/windsurf/mcp_config.json
  const mcpConfigPath = join(homedir(), '.codeium', 'windsurf', 'mcp_config.json');
  upsertMcpConfig(mcpConfigPath, projectPath, 'mcpServers', mcpEntry(projectPath, devMode), result);

  // 2. Project: .windsurfrules (thin pointer)
  ensureFile(join(projectPath, '.windsurfrules'), RULES_POINTER, result);

  // 3. AGENTS.md redirect
  ensureAgentsRedirect(projectPath, result);

  result.messages.push('Windsurf: MCP server + .windsurfrules configured');
  return result;
}
