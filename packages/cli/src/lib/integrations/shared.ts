/**
 * ToolAdapter interface + SSOT content templates + shared file helpers.
 * Mirrors: apps/hub/src-tauri/src/infrastructure/integrations/adapter_trait.rs
 */
import { existsSync, mkdirSync, readFileSync, writeFileSync, unlinkSync } from 'node:fs';
import { join, resolve } from 'node:path';
import type { IntegrationTool, IntegrationResult, IntegrationConfig } from './types.js';

// ── ToolAdapter Interface ────────────────────────────────────────────────────

/**
 * Infrastructure trait — each AI tool adapter implements this.
 * Mirrors Rust `ToolAdapter` trait in `adapter_trait.rs`.
 */
export interface ToolAdapter {
  readonly tool: IntegrationTool;
  integrate(projectPath: string, devMode: boolean): IntegrationResult;
  remove(projectPath: string): IntegrationResult;
  check(projectPath: string): IntegrationConfig;
}

// ── SSOT Content Templates ───────────────────────────────────────────────────

export const AGENTS_REDIRECT = `# AGENTS.md

> Cross-tool AI instructions for aidd.md projects.

## Startup Protocol

**At the start of every conversation, do one of the following:**

1. **MCP available** — Call the \`aidd_start\` MCP tool.
2. **MCP unavailable** — Run \`pnpm mcp:check\` in the terminal.

## Agent Definitions

See [.aidd/content/routing.md](.aidd/content/routing.md) for the full agent hierarchy and task dispatch.
`;

export const RULES_POINTER = `This project uses the aidd.md framework for AI-Driven Development.

## Startup Protocol

At the start of every conversation, call the \`aidd_start\` MCP tool.
If MCP is unavailable, run \`pnpm mcp:check\` in the terminal.

## Framework

- Framework router: \`.aidd/content/routing.md\`
- Domain rules: \`.aidd/content/rules/\`
- Skills: \`.aidd/content/skills/\`
- Workflows: \`.aidd/content/workflows/\`

Follow the patterns and conventions defined in these directories.
`;

export function projectInstructions(projectName: string, toolName: string, mcpNote: string): string {
  return `# ${projectName} — ${toolName} Instructions

> Auto-generated by aidd.md. Edit freely.

## Startup Protocol

**At the start of every conversation, do one of the following:**

1. **MCP available** — Call the \`aidd_start\` MCP tool.
2. **MCP unavailable** — Run \`pnpm mcp:check\` in the terminal.

## SSOT

\`.aidd/content/routing.md\` is the canonical source of truth for agent roles and task dispatch.

## Framework

This project uses the [aidd.md](https://aidd.md) framework for AI-Driven Development:
- **.aidd/content/routing.md** — Framework router (single entrypoint)
- **.aidd/content/rules/** — Domain-specific rules
- **.aidd/content/skills/** — Specialized capabilities
- **.aidd/content/workflows/** — Multi-step procedures

## MCP Integration

${mcpNote}
`;
}

// ── Shared Helpers ───────────────────────────────────────────────────────────

export function projectName(projectPath: string): string {
  return projectPath.split(/[\\/]/).pop() ?? 'Project';
}

/** Build MCP server JSON entry. Dev mode points to local build; otherwise uses npx. */
export function mcpEntry(projectPath: string, devMode: boolean): Record<string, unknown> {
  if (devMode) {
    return {
      command: 'node',
      args: [join(projectPath, 'mcps', 'mcp-aidd-engine', 'dist', 'index.js')],
      env: { AIDD_PROJECT_PATH: projectPath },
    };
  }
  return {
    command: 'npx',
    args: ['-y', '@aidd.md/mcp-engine'],
    env: { AIDD_PROJECT_PATH: projectPath },
  };
}

/** Detect dev mode: true if the local engine build exists. */
export function detectDevMode(projectPath: string): boolean {
  return existsSync(join(resolve(projectPath), 'mcps', 'mcp-aidd-engine', 'dist', 'index.js'));
}

/** Factory for empty IntegrationResult. */
export function emptyResult(tool: IntegrationTool): IntegrationResult {
  return { tool, files_created: [], files_modified: [], messages: [] };
}

/** Upsert the aidd-engine entry in an MCP JSON config file. */
export function upsertMcpConfig(
  configPath: string,
  serversKey: string,
  entry: Record<string, unknown>,
  result: IntegrationResult,
): void {
  const dir = join(configPath, '..');
  if (!existsSync(dir)) mkdirSync(dir, { recursive: true });

  let config: Record<string, unknown> = {};
  if (existsSync(configPath)) {
    try {
      config = JSON.parse(readFileSync(configPath, 'utf-8'));
      result.files_modified.push(configPath);
    } catch {
      result.files_modified.push(configPath);
    }
  } else {
    result.files_created.push(configPath);
  }

  const servers = (config[serversKey] ?? {}) as Record<string, unknown>;
  servers['aidd-engine'] = entry;
  config[serversKey] = servers;
  writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf-8');
}

/** Remove the aidd-engine entry from an MCP JSON config file. */
export function removeMcpEntry(
  configPath: string,
  serversKey: string,
  result: IntegrationResult,
): void {
  if (!existsSync(configPath)) return;
  try {
    const config = JSON.parse(readFileSync(configPath, 'utf-8')) as Record<string, unknown>;
    const servers = config[serversKey] as Record<string, unknown> | undefined;
    if (servers && 'aidd-engine' in servers) {
      delete servers['aidd-engine'];
      writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf-8');
      result.files_modified.push(configPath);
    }
  } catch {
    // Malformed JSON — skip
  }
}

/** Check if an MCP JSON file has an aidd-engine entry. Returns [has_entry, is_dev_mode]. */
export function checkMcpEntry(configPath: string, serversKey: string): [boolean, boolean] {
  if (!existsSync(configPath)) return [false, false];
  try {
    const config = JSON.parse(readFileSync(configPath, 'utf-8')) as Record<string, unknown>;
    const servers = config[serversKey] as Record<string, unknown> | undefined;
    if (!servers || !('aidd-engine' in servers)) return [false, false];
    const entry = servers['aidd-engine'] as Record<string, unknown>;
    const isDevMode = entry?.command === 'node';
    return [true, isDevMode];
  } catch {
    return [false, false];
  }
}

/** Create a file if it doesn't exist, recording in result. */
export function ensureFile(filePath: string, content: string, result: IntegrationResult): void {
  if (existsSync(filePath)) return;
  const dir = join(filePath, '..');
  if (!existsSync(dir)) mkdirSync(dir, { recursive: true });
  writeFileSync(filePath, content, 'utf-8');
  result.files_created.push(filePath);
}

/** Remove a file if it exists. Returns true if removed. */
export function removeFileIfExists(filePath: string): boolean {
  if (!existsSync(filePath)) return false;
  unlinkSync(filePath);
  return true;
}

/** Ensure AGENTS.md thin redirect at project root. */
export function ensureAgentsRedirect(projectPath: string, result: IntegrationResult): void {
  ensureFile(join(projectPath, 'AGENTS.md'), AGENTS_REDIRECT, result);
}

/** Check if the routing file exists (or legacy agents directory). */
export function hasAgentsDir(projectPath: string): boolean {
  return existsSync(join(projectPath, '.aidd', 'content', 'routing.md'))
    || existsSync(join(projectPath, '.aidd', 'content', 'agents'));
}
